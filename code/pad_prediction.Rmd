---
title: "PAD-prediction"
output:
  html_notebook: default
  word_document: default
  pdf_document: default
---

#### Libraries used in the Project and uploading data

```{r}
library(tidyverse)
library(dplyr)
library(stringr)
library(svMisc)
library(ggplot2)
library(gtable)
library("ggpubr")
library(data.table)


log_data <- read_csv("~/Desktop/PAE/github/data/logData.csv")

log_data_saver <- log_data

log_data <- unique(log_data)

#MAKE IT ALL UPPER!!!

log_data$logInfo <- toupper(log_data$logInfo)

### GETTING THE DATE MONTH AND YEAR IF I WANT!!!
extractdate <- function(date) {
    day <- format(date, format="%d")
    month <- format(date, format="%m")
    year <- format(date, format="%Y")

    cbind(day, month, year)
}

#making first calls
first_call<-extractdate(log_data$callTime)


#making last call
last_day <-substr(log_data$lastCallTime, 9, 10)
last_month <- substr(log_data$lastCallTime, 6, 7)
last_year <-substr(log_data$lastCallTime, 1, 4)

log_data<-cbind(log_data, first_call,last_day,last_month,last_year)

#Converting columns to numeric
log_data$day <-as.numeric(log_data$day)
log_data$last_day <- as.numeric(log_data$last_day)
log_data$month <-as.numeric(log_data$month)
log_data$last_month <- as.numeric(log_data$last_month)
log_data$year <- as.numeric(log_data$year)
log_data$last_year <- as.numeric(log_data$last_year )


log_data$year <- log_data$year +log_data$month/12
log_data$last_year <- log_data$last_year + log_data$last_month/12

log_data$caller_lifetime <- log_data$last_year - log_data$year
```

DOING THE WHOLE DF PER CALLER - INCORRECT, BUT WORTH KEEPING!
```{r}
lang_spoken <- log_data %>%
  group_by(callerId, langId) %>%
  count()


#Distribution of time difference bewtween first and last call

lifetime<- log_data %>%
  group_by(callerId, caller_lifetime) %>%
  count()


#distribution of calls made

calls_made <- log_data %>%
  group_by(callerId, noCallsMade) %>%
  count()

content_listened <- filter(log_data, grepl("CONTENT",logInfo))
content_listened <- filter(content_listened , !grepl("CONTENT MENU",logInfo))
content_listened <- filter(content_listened , !grepl("CONTENT IS NOT AVAILABLE",logInfo))

#Creating a content#_played column
content_listened$content_played <- ifelse(str_detect(content_listened$logInfo, 'CONTENT PLAYED', negate = FALSE),1,0)
content_listened$replay_request <- ifelse(str_detect(content_listened$logInfo, 'CONTENT REPLAY REQUESTED', negate = FALSE),1,0)

content_played<-aggregate(content_listened$content_played,list(content_listened$callerId), FUN=sum)
?rename
content_played <- content_played %>% 
  dplyr::rename(
    con_play = x,
    callerId = Group.1
    )

content_replay<-aggregate(content_listened$replay_request,list(content_listened$callerId), FUN=sum)
content_replay <- content_replay %>% 
 dplyr::rename(
    con_replay = x,
    callerId = Group.1
    )

content_counts <- cbind(content_played, content_replay)

content_counts$adjusted_con <- content_counts$con_play-content_counts$con_replay

content_counts$callerId <- NULL

summary(content_counts$adjusted_con)




# Getting the number of calls per person
calls_made <- log_data %>%
  dplyr::group_by(callerId, noCallsMade, langId) %>%
  count()

#join between tables
content_ratio <- left_join(calls_made, content_counts,by="callerId")
content_ratio[is.na(content_ratio)] <- 0

content_ratio$ratio <- content_ratio$adjusted_con/content_ratio$noCallsMade

# QUICKLY GETTING PER CALL for the average call


tester <- log_data %>% 
  group_by(callerId, callId) %>%
  count()

tester$n <- NULL

tester <- tester%>% 
  group_by(callerId) %>%
  count()

per_call_df_copy <- per_call_df
per_call_per_caller <- aggregate(per_call_df$content, by=list(Category=per_call_df$callerId), FUN=sum)
per_call_per_caller$callerId<- per_call_per_caller$Category

per_call_per_caller <- left_join(per_call_per_caller, tester ,by="callerId")

per_call_per_caller$ratio <- round(per_call_per_caller$x/per_call_per_caller$n,2)

#THIS IS THE FINAL RATIO FOR CALLERS REEACHING CONTENT - THE PERCENTAGE OF TIMES A CALLER CALLS AND GETS TO CONTENT!!!!!!!!
summary(per_call_per_caller$ratio)


ggplot(per_call_per_caller, aes(x=ratio))+
  geom_histogram(color="black", fill="green", bins=20) +
  labs(
    title = 'Percentage of Calls ending in Content grouped by caller
     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0000  0.2900  0.5000  0.4752  0.6700  1.0000 ',
    y='Count',
    x='Percentage Reached Content'
  )


#Final join to get max possible data
prediction <- log_data %>%
  dplyr::group_by(callerId, noCallsMade, noContentListened,caller_lifetime,
                  day,month,year,last_day,last_month,last_year) %>%
  count()

prediction$noCallsMade <- NULL


prediction_df <-  left_join(content_ratio, prediction,by="callerId")

write.csv(prediction_df, '~/Desktop/PAE/github/data/caller_data.csv', row.names = FALSE)

```


Same thing per call
```{r}

content_list_call <- filter(log_data, grepl("CONTENT",logInfo))
content_list_call <- filter(content_list_call , !grepl("CONTENT MENU",logInfo))
content_list_call <- filter(content_list_call , !grepl("CONTENT IS NOT AVAILABLE",logInfo))

#Creating a content#_played column
content_list_call$content_played <- ifelse(str_detect(content_list_call$logInfo, 'CONTENT PLAYED', negate = FALSE),1,0)
content_list_call$replay_request <- ifelse(str_detect(content_list_call$logInfo, 'CONTENT REPLAY REQUESTED', negate = FALSE),1,0)

content_played<-aggregate(content_list_call$content_played,list(content_list_call$callId), FUN=sum)
?rename
content_played <- content_played %>% 
  dplyr::rename(
    con_play = x,
    callId = Group.1
    )

content_replay<-aggregate(content_list_call$replay_request,list(content_list_call$callId), FUN=sum)
content_replay <- content_replay %>% 
 dplyr::rename(
    con_replay = x,
    callId = Group.1
    )

content_counts_call <- cbind(content_played, content_replay)

content_counts_call$adjusted_con <- content_counts_call$con_play-content_counts_call$con_replay

content_counts_call$callId <- NULL


# YOU HAVE TO JOIN BACK TO FIND OUT THE ZERO CONTENT

prediction <- log_data %>%
  dplyr::group_by(callerId, noCallsMade, noContentListened,caller_lifetime,
                  day,month,year,last_day,last_month,last_year) %>%
  count()

calls_made_total <- log_data %>%
  dplyr::group_by(callId, noCallsMade, noContentListened,caller_lifetime,
                  day,month,year,last_day,last_month,last_year) %>%
  count()

calls_callers <- log_data %>%
  dplyr::group_by(callerId, callId) %>%
  count()


per_call_df <-  left_join(calls_made_total, content_counts_call,by="callId")

#getting back the call id
per_call_df <-  left_join(per_call_df , calls_callers ,by="callId")

per_call_df[is.na(per_call_df)] <- 0

per_call_df$depth <- per_call_df$n

per_call_df$content <- ifelse(per_call_df$con_play > 0, 1,0)

class(log_data$eventTime[10]-log_data$eventTime[20])

summary(per_call_df$content)

#VERY QUICKLY 
```


#get the length of every single call  and time to content
```{r}

#doing call length
call_length<- dplyr::filter(log_data, grepl("INCOMING",logInfo)|grepl("HUNG",logInfo))
call_length <- call_length %>%
    group_by(callId) %>%
    mutate(call_time = eventTime - lag(eventTime))

call_length <- call_length %>% 
  drop_na() %>%
  select(call_time)


per_call_df <-  left_join(per_call_df, call_length,by="callId")

per_call_df <- per_call_df %>%
  drop_na()

summary(as.numeric(per_call_df$call_time))

ggplot(per_call_df , aes(x=call_time)) +
  geom_histogram(color="black", fill="blue") +
  xlim(0,1000)+
  labs(
    title = ' \n
Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0    22.0    77.0   143.9   189.0  3409.0',
    x = 'Call length'
  )


?drop_na()

#write.csv(per_call_df, '~/Desktop/PAE/github/data/per_call_df.csv', row.names = FALSE)

#time to content 1
time_to_content<- dplyr::filter(log_data, grepl("INCOMING",logInfo)|grepl("CONTENT PLAYED",logInfo))
time_to_content<- time_to_content%>%
    group_by(callId) %>%
    mutate(to_content = eventTime - lag(eventTime))

time_to_content <-time_to_content %>% 
  group_by(callId) %>% 
  filter(row_number()==2)

ggplot(time_to_content , aes(x=to_content)) +
  geom_histogram(color="black", fill="blue") +
  xlim(0,400)+
    labs(
    title = ' \n
Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0    22.0    77.0   143.9   189.0  3409.0',
    x = 'time to content'
  )
  

ggplot(per_call_per_caller, aes(x=n)) +
  geom_histogram(color="black", fill="blue")+
  xlim(0,50)

```

#distributions of positives versus negatives and call time


```{r}
made_it <- per_call_df %>%
  filter(content == 1)

summary(as.numeric(made_it$call_time))

no_made <- per_call_df %>%
  filter(content == 0)

summary(as.numeric(no_made$call_time))

ggplot(per_call_df, aes(call_time))+
  geom_histogram(aes(fill=as.factor(content)), position = "identity", bins = 30, alpha = 0.4)+
  scale_fill_manual(
    name = "Content Reached",
    values = c("red", "green"),
    labels = c("No", "Yes"))+
  labs(
    title='Distribution of Calls',
    x='Total Seconds On Call')+
  xlim(0,1000)
  



```


Showing how long it took for each color to get to call
```{r}

summary(as.numeric(no_made$call_time))

ggplot(time_to_content , aes(x=to_content)) +
  geom_histogram(aes(fill="green"),alpha = 0.4) +
  geom_histogram(data = no_made, aes(as.numeric(call_time), fill="red"),alpha = 0.4) +
  geom_histogram(data = made_it, aes(as.numeric(call_time), fill="blue"),alpha = 0.4)+
  scale_fill_manual(
    name = "(John) Legend",
    values = c("green", "blue", 'red'),
    labels = c("Content Reached - \n Total time on call", "Content Reached - \n Time to 1st Content", "No Conted Reached - \n Total time on call"))+
  xlim(0,100)+
  #theme_minimal(base_size = 14) +
  #theme(legend.key = element_rect(color = NA, fill = NA),
  #      legend.key.size = unit(1, "cm")) +
  #theme(legend.title.align = .5)+
  theme_bw()+
   theme(legend.key.size = unit(3, 'lines'))+
  labs(x = 'Time in Seconds')
```


```{r}
no_made$depth <- no_made$n.x

ggplot(no_made, aes(x=n.x))+
  geom_histogram(color="black", fill="blue") +
  xlim(0,20)+
    labs(
    x = 'steps'
  )


no_content_5step <- no_made %>%
  filter(depth ==5)

no_content_5step <- right_join(log_data, no_content_5step, by='callId')


aggregate(no_content_5step$callId, by=list(no_content_5step$logInfo), FUN=last)

no_content_5step <- no_content_5step %>% group_by(callId) %>% summarise(last_log = nth(logInfo,4))

table(no_content_5step$last_log)

```




# HOW LONG ARE PEOPLE SPENDING ON THE CROP MENU

```{r}
#doing call length
crop_menu_length<- dplyr::filter(log_data, grepl("INCOMING",logInfo)|grepl("HUNG",logInfo))
call_length <- call_length %>%
    group_by(callId) %>%
    mutate(call_time = eventTime - lag(eventTime))

call_length <- call_length %>% 
  drop_na() %>%
  select(call_time)
```

